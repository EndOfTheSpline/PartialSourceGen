using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace PartialSourceGen.Generators;

/// <summary>
/// An incremental generator for constructing partial entities
/// </summary>
[Generator]
public class PartialIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string Disclaimer = """
    //------------------------------------------------------------------------------
    // <auto-generated>
    //     This code was generated from a template.
    //
    //     Manual changes to this file may cause unexpected behavior in your application.
    //     Manual changes to this file will be overwritten if the code is regenerated.
    // </auto-generated>
    //------------------------------------------------------------------------------

    """;

    private const string SourceAttribute = """

    using System;

    namespace PartialSourceGen
    {
        #nullable enable
        /// <summary>
        /// Generate partial optional properties of this class/struct.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
        public class PartialAttribute : Attribute
        {
            /// <summary>
            /// The optional summary for the partial entity. If not given
            /// the original summary will be used.
            /// </summary>
            public string? Summary { get; set; }

            /// <summary>
            /// If true, required properties will maintain their required modifier.
            /// If false, the partial entity will remove the required modifier.
            /// </summary>
            public bool IncludeRequiredProperties { get; set; }

            /// <summary>
            /// The optional class name for the partial entity.
            /// If not specified, the naming convection will be Partial[ClassName]
            /// </summary>
            public string? PartialClassName { get; set; }
        }
        #nullable disable
    }
    """;

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("PartialAttribute.g.cs", SourceText.From(Disclaimer + SourceAttribute, Encoding.UTF8)));

        var candidates = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "PartialSourceGen.PartialAttribute",
            predicate: static (n, _) => n.IsKind(SyntaxKind.ClassDeclaration)
                                 || n.IsKind(SyntaxKind.StructDeclaration)
                                 || n.IsKind(SyntaxKind.RecordDeclaration)
                                 || n.IsKind(SyntaxKind.RecordStructDeclaration),
            transform: SemanticTransform)
            .Where(static n => n is not null);

        context.RegisterSourceOutput(candidates, static (spc, source) => Execute(in source, spc));
    }

    private PartialInfo? SemanticTransform(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        context.Attributes.SingleOrDefault(a => a.NamedArguments.Any(n => n.Key == ""));
        if (context.TargetSymbol is not INamedTypeSymbol nameSymbol)
        {
            return null;
        }

        var root = context.SemanticModel.SyntaxTree.GetRoot(token);
        var props = root.DescendantNodes().OfType<PropertyDeclarationSyntax>();
        if (!props.Any())
        {
            return null;
        }

        var name = nameSymbol.Name;
        var givenName = context.GetPartialClassName();
        var node = context.TargetNode;
        var summary = context.GetSummaryText();
        var includeRequired = context.GetIncludeRequiredProperties();
        return new(
            givenName ?? ("Partial" + name),
            summary,
            includeRequired,
            root,
            node,
            props.ToArray()
        );
    }

    private static void Execute(in PartialInfo? source, SourceProductionContext spc)
    {
        if (!source.HasValue)
        {
            return;
        }

        var (name, summaryTxt, includeRequired, root, node, originalProps) = source.GetValueOrDefault();
        List<PropertyDeclarationSyntax> optionalProps = [];
        foreach (var prop in originalProps)
        {
            TypeSyntax propertyType;
            if (prop.Type is NullableTypeSyntax nts)
            {
                propertyType = nts;
            }
            else
            {
                propertyType = SyntaxFactory.NullableType(prop.Type);
            }

            var propName = prop.Identifier.ValueText.Trim();

            IEnumerable<SyntaxToken> modifiers = prop.Modifiers;
            if (!includeRequired)
            {
                // Remove the required keyword
                modifiers = prop.Modifiers.Where(m => !m.IsKind(SyntaxKind.RequiredKeyword));
            }
            else
            {
                var hasRequiredAttribute = prop.AttributeLists.SelectMany(attrs => attrs.Attributes.Select(a => a.Name.GetText().ToString()))
                                                   .Any(s => s.StartsWith("Required", System.StringComparison.OrdinalIgnoreCase));

                if (prop.Modifiers.Any(m => m.IsKind(SyntaxKind.RequiredKeyword)) || hasRequiredAttribute)
                {
                    // Retain original type
                    propertyType = prop.Type;
                }
            }

            // new optional property
            PropertyDeclarationSyntax optionalProp;

            if (prop.ExpressionBody is null)
            {
                optionalProp = SyntaxFactory
                        .PropertyDeclaration(propertyType, propName)
                        .WithModifiers(SyntaxFactory.TokenList(modifiers))
                        .WithLeadingTrivia(prop.GetLeadingTrivia())
                        .WithAccessorList(prop.AccessorList);
            }
            else
            {
                optionalProp = SyntaxFactory
                        .PropertyDeclaration(propertyType, propName)
                        .WithLeadingTrivia(prop.GetLeadingTrivia())
                        .WithModifiers(SyntaxFactory.TokenList(modifiers))
                        .WithAccessorList(prop.AccessorList)
                        .WithExpressionBody(prop.ExpressionBody)
                        .WithSemicolonToken(prop.SemicolonToken);
            }


            optionalProps.Add(optionalProp);
        }

        var leadingTrivia = node.GetLeadingTrivia().FirstOrDefault(trivia => trivia.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia));

        var members = optionalProps.ToArray();
        SyntaxNode? partialType = node switch
        {
            RecordDeclarationSyntax record => SyntaxFactory
                .RecordDeclaration(record.Kind(), record.Keyword, name)
                .WithClassOrStructKeyword(record.ClassOrStructKeyword)
                .WithModifiers(record.Modifiers)
                .WithConstraintClauses(record.ConstraintClauses)
                .WithTypeParameterList(record.TypeParameterList)
                .WithOpenBraceToken(record.OpenBraceToken)
                .AddMembers(members)
                .WithCloseBraceToken(record.CloseBraceToken),
            StructDeclarationSyntax val => SyntaxFactory
                .StructDeclaration(name)
                .WithModifiers(val.Modifiers)
                .WithTypeParameterList(val.TypeParameterList)
                .WithConstraintClauses(val.ConstraintClauses)
                .WithOpenBraceToken(val.OpenBraceToken)
                .AddMembers(members)
                .WithCloseBraceToken(val.CloseBraceToken),
            ClassDeclarationSyntax val => SyntaxFactory
                .ClassDeclaration(name)
                .WithModifiers(val.Modifiers)
                .WithTypeParameterList(val.TypeParameterList)
                .WithConstraintClauses(val.ConstraintClauses)
                .WithOpenBraceToken(val.OpenBraceToken)
                .AddMembers(members)
                .WithCloseBraceToken(val.CloseBraceToken),
            _ => null
        };

        if (partialType is null)
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(summaryTxt))
        {
            partialType = partialType.WithLeadingTrivia(partialType.GetLeadingTrivia().InsertRange(0, [leadingTrivia]));
        }
        else
        {
            var txt = "/// <summary>\n" + @"/// " + summaryTxt + "\n" + "/// </summary>\n";
            var summaryNode = SyntaxFactory.TriviaList(SyntaxFactory.ParseLeadingTrivia(txt)).Insert(0, SyntaxFactory.CarriageReturnLineFeed);
            partialType = partialType.WithLeadingTrivia(summaryNode);
        }

        var nullableDirective = SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.EnableKeyword), true);
        var nullableTrivia = SyntaxFactory.Trivia(nullableDirective);

        var newRoot = root
            .ReplaceNode(node, partialType)
            .WithLeadingTrivia(nullableTrivia)
            .NormalizeWhitespace();

        var newTree = SyntaxFactory.SyntaxTree(newRoot, root.SyntaxTree.Options);
        var sourceText = newTree.GetText().ToString();

        spc.AddSource(name + ".g.cs", Disclaimer + sourceText);
    }
}

internal readonly record struct PartialInfo
{
    public PartialInfo(
        string name,
        string? summary,
        bool includeRequired,
        SyntaxNode root,
        SyntaxNode node,
        PropertyDeclarationSyntax[] properties)
    {
        Name = name;
        Summary = summary;
        IncludeRequired = includeRequired;
        Root = root;
        Node = node;
        Properties = properties;
    }

    public string Name { get; }
    public string? Summary { get; }
    public bool IncludeRequired { get; }
    public SyntaxNode Root { get; }
    public SyntaxNode Node { get; }
    public PropertyDeclarationSyntax[] Properties { get; }

    public void Deconstruct(out string name, out string? summary, out bool includeRequired, out SyntaxNode root, out SyntaxNode node, out PropertyDeclarationSyntax[] properties)
    {
        name = Name;
        summary = Summary;
        includeRequired = IncludeRequired;
        root = Root;
        node = Node;
        properties = Properties;
    }
}